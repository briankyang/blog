---
title: JDK基础汇总
date: 2020-03-24 23:01:08
tags:
---

# JVM

## JMM

### as-if-serial

单线程内编译器、处理器都不会对有数据依赖关系的操作进行重排序

### 内存屏障

内存屏障指令用来告诉处理器在此指令执行的时候，先于这个命令的必须先执行，后于这个命令的都必须后执行，并在此处刷新缓冲区到主存。如果字段是volatile，java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：

- 一旦你完成写入，任何访问这个字段的线程将会得到最新的值

- 在你写入之前，会保证所有之前应该发生的事都已发生，并且任何更新过的volatile数据也都被刷新到了主存，是可见的。

### Happens-Before

如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间就必须要存在happens-before关系，这是一种编程上的约束，jmm在实现的时候会禁止改变程序执行结果的重排序，但不会禁止不改变程序执行结果的重排序。

临界区内的指令可以重排序，但jmm不允许临界区内的指令“逸出”到临界区外，那样会破坏监视器的语义，jmm会在退出临界区和进入临界区这两个关键事件点做一些特别处理。

###### Happens-Before规则之无需任何同步手段就可以保证的

- 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作

- 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁

- volatile变量规则：对一个volatile变量的写，happens-before于任意后续对这个volatile变量的读

- 传递性：如果A happens-before B, 且B happens-before C， 那么A happens-before C

- start（）规则：如果线程A执行ThreadB.start()，那么线程A的ThreadB.start() happens-before于线程B中的任意操作

- join（）规则：如果线程A执行ThreadB.join() 并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回

- 线程中断规则：对线程interrupt方法的调用happens-before于被终端线程的代码检测到中断事件的发生

### 实现原理

- volatile的内存语义
  
  - volatile变量自身具有以下特性
    
    - 可见性：对一个volatile变量的读，总能看到（任意线程）对这个volatile变量最后的写入（写入的操作happens-before当前线程对volatile这个变量的读）
    
    - 原子性：对任意单个volatile变量的读写具有原子性，但类似于volatile++这种复合操作不具有原子性
  
  - volatile写的语义如下：当写一个volatile变量时，jmm会把该线程对应的本地内存中的共享变量值立即刷入到主内存（会在写指令后执行写屏障指令来完成）
  
  - volatile读的内存语义：当读一个volatile变量时，jmm会把该线程对应的本地缓存置为无效，线程将接卸来从主内存中读取共享变量

- 锁的内存语义
  
  - 当线程释放锁时，jmm会把该线程对应的本地内存中的共享变量刷新到主内存中
  
  - 当线程获取锁时，jmm会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主存中读取共享变量
  
  - synchronized的实现原理：使用monitorenter和monitorexit指令实现
    
    - monitorenter指令在编译后插入到同步代码块开始的位置，而monitorexit是插入到方法结束处和异常处（实现步骤）
    
    - 每个monitorenter必须有对应的monitorexit与之对应（约束）
    
    - 任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态
    
    - 锁存放的位置
      
      - 锁信息存放在对象MarkWord当中
    
    - 锁信息由MarkWord中的bit位标识，而markword是被复用的字段，其后3位标识了当前markword的意义
      
      - 后两位00表示轻量级锁，然后前面的进制位是指向栈中锁记录的指针
        
        - 优点：竞争线程不会阻塞，提高了程序的响应速度
        
        - 缺点：如果始终得不到锁竞争的线程，使用自旋会消耗cpu
        
        - 使用场景：追求响应时间，同步块执行速度非常快
      
      - 后两位11表示重量级锁，然后前面的是指向互斥锁的指针
        
        - 优点：线程竞争不会使用自选，不会消耗cpu
        
        - 缺点：线程阻塞，响应时间缓慢
        
        - 使用场景：追求吞吐量、同步块执行速度较长
      
      - 11表示需要被gc
      
      - 01分两种情况：
        
        - 前一位是1：表示偏向锁，此前29个进制位的信息为：线程id（23位），epoch，对象分代年龄
          
          - 优点：加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级别的差别
          
          - 缺点：如果线程间存在锁竞争，会带来额外的锁撤销的消耗
          
          - 使用于只有一个线程访问同步块的场景
        
        - 前一位是0：表示无锁状态，此前29个进制位信息位：hashCode（25bit），对象分代年龄（4bit）
  
  - final的内存语义
    
    - 编译器和处理器要遵守两个重排序规则
      
      - 在构造器内对一个final域的写入，于随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序
      
      - 初次读一个包含final域的对象的引用，于随后初次读这个final域，这两个操作之间不能重排序（看不懂）
    
    - final域为引用类型
      
      - 在构造器内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序
    
    - final语义在处理器中的实现
      
      - 会要求编译器在final域的写入后，构造函数return之前插入一个storestore屏障
      
      - 读final域的重排序规则要求编译器在读final域的操作前面插入一个loadload屏障

# 锁膨胀与锁升级

偏向锁 -> 轻量级锁 -> 自旋锁 -> 重量级锁

偏向第一个拿到锁的线程，第一个拿到锁的线程会在markword中通过cas记录线程id，此后每次拿锁都不需要cas，如果该线程执行同步代码块时有其他线程在竞争，会被升级为轻量级锁，如果其他线程发现markword里不是自己，且原有偏向锁的线程已经执行完同步代码块，则会尝试cas把记录线改为自己。

轻量级锁

jvm会给线程的栈帧中创建一个锁记录空间，把对象头复制到该空间里，并通过cas尝试把markword中的锁记录指向该锁记录，如果成功则拿到锁，失败则自旋

自旋锁

膨胀为重量级锁前，线程在执行monitorenter指令进入等待队列时，会通过自旋锁去尝试获得锁，如果自旋超过一定次数，则会进入阻塞态，等待内核调度，此时会发生内核态和用户态之间的上下文切换，会影响性能，因为后面的线程也会尝试进行自旋获取锁，所以此时对已被阻塞的那些线程来说不公平。

重量级锁

通过内核来操作线程，因频繁出现内核态和用户态的切换，会严重影响性能

# 垃圾回收

## 垃圾回收算法

- 标记清除
  
  - 最基础的算法
  
  - 主要缺点
    
    - 效率问题，标记和清除过程效率不高
    
    - 空间问题，标记清除后会产生大量不连续的内存碎片

- 标记-整理算法
  
  - 标记操作和标记清除算法一致，后续操作不只是直接清理对象，而是在清理无用对象后完成然所有存活的对象都向一端移动，并更新引用其对象的指针
  
  - 缺点：在标记清除的基础上还需要移动对象和更新引用指针，代价大
  
  - 好处：不会产生内存碎片

- 复制算法
  
  - 主要用于回收新生代，将可用内存划分为大小相等的两块，每次只使用其中一块，当一块用完之后，就将还存货的对象移到另一块上面，而且对每个对象的年龄加1，然后清除已经使用过的内存，这样每次都不会产生碎片，只要移动堆顶的指针，按顺序分配内存即可，实现简单，运行高效
  
  - 缺点：可用内存缩小为原来一半

- 分代收集算法
  
  - 基于一个事实：不同对象的生命周期不同，因此，不同生命周期的对象可以采取不同的回收算法，以便高效回收
  
  - 年轻代：新生代内存按照8：1：1分成eden区和两个survivor区
    
    - 应用程序只能使用一个新生代和一个复活代，当发生初级垃圾回收的时候，gc挂起程序，将新生代和复活代中的存活对象复制到另一个非活动的复活代，然后一次性清除新生代和复活代，将原来的非复活代标记成为活动复活代，将在指定次数后仍然存活的对象移到老年代中，初级回收后，得到一个新的可用的新生代
  
  - 老年代：标记清除算法

可达性分析：

- GCroots：
  
  -  虚拟机栈，栈帧中的本地变量表中引用的对象
  
  - 方法区中加载的类的静态属性引用的对象
  
  - 方法区中常量引用的对象
  
  - 本地方法栈中引用的对象
  
  - HotSpot需要确定gcroots时，并不需要遍历整个方法区或堆，而是知道哪些地方存放着对象的引用，这是有一个叫OopMap的数据结构来实现的

类的回收条件

- 该类产生的对象实例已全部被回收

- 加载该类的类加载器已被回收

- 该类的类对象没有任何在任何地方引用，无法反射出这个类的方法

# JAVA并发

## 线程切换

- java线程状态：
  
  - 初始：创建了线程对象，还没start
  
  - 运行：java线程中将就绪和运行两种状态统称为运行
  
  - 阻塞：表示线程阻塞于锁
  
  - 等待：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）
  
  - 超时等待：可以在指定的时间内自行返回
  
  - 终止：表示该线程已经执行完毕

- 同步队列
  
  - 抢锁的时候没有抢到锁线程进入对象的同步队列
  
  - 抢到锁后再wait会进入对象的等待队列
  
  - 抢到锁后再调用notify则会让等待队列的线程进入同步队列
  
  - LockSupport.park或unpark都只是让对象进入等待状态或唤醒，juc中使用这种方式来竞争锁。
