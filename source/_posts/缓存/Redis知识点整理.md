---
title: Redis知识点整理
date: 2020-03-21 14:57:38
tags:
---

# Redis知识点整理

## 数据类型

- String
  
  - 应用
    
    - 缓存热点数据
    - 计数器
    - 会话token
  
  - 底层结构
    
    - SDS存储(还被用做缓冲区AOF模块的AOF缓冲区)
    
    - ```c
      struct sdshdr {
      
          //buf中已占用的长度
          int len;
      
          // 剩余可用空间长度
          int free;
      
          //数据空间
          char buf[];
      }
      ```

- Hash
  
  - 应用
    - redisson的使用lua实现的分布式锁
  - 底层结构
    - 包含两个哈希表的字典结构体

- List
  
  - 应用
    - 简单消息队列
  - 底层结构
    - 链表

- Set

- SortedSet
  
  - 底层结构
    - 集合键使用跳表实现
      - 跳表数据结构相当于给原始链表加上多级索引
      - 通过随机函数维持平衡性，当往跳表中插入数据时，通过随机函数决定这个节点插入到哪几级索引层中，如生成k，则插入到1到k层的索引中

<!-- more -->

## 持久化

#### RDB(自动和手工)

- 自动
  
  - 服务器会让客户设置一些条件，如多少秒内进行了多少次修改，然后redis遇到条件满足时，会执行bgsave
  
  - 使用子进程做持久化

- 5分钟生成一次快照

- 优点
  
  - 数据恢复时加载快

- 缺点
  
  - 异步生成(bgsave)
    
    - 5分钟期间内若发生过down机, 数据丢失较多
  
  - 同步生成快照(save)
    
    - 生成快照过程中若文件很大，会导致客户端卡顿

#### AOF

- AOF通过保存所有修改数据库的写命令来记录服务器的数据库状态

- 写命令会先记录在AOF缓冲区中，然后定期写入到AOF文件

- 每秒通过后台线程将AOF缓冲区内容刷新到AOF文件

- 优点
  
  - 若down机则数据丢失可能会少一些

- 缺点
  
  - 因每秒异步刷新日志，qps会降低

## 内存淘汰

#### 过期策略

- 定时删除
  
  - 固定每100ms随机抽取一些设置了过期时间的key, 去检查是否过期

- 惰性删除
  
  - 查询时再判断是否过期, 过期的话就删除键不返回值

#### 内存淘汰机制

- 新增数据发现内存达到限制时，触发内存淘汰机制
  
  - LRU
    
    - 尝试回收最少使用的键
  
  - LFU
    
    - 尝试回收最近最不常用的键
  
  - 随机删除

- 近似LRU
  
  - 对少量键取样，然后回收最久未被访问的键

## 线程模型

- select处理客户端连接

- 单线程处理模型
  
  - redis瓶颈在于网络延迟, 而非cpu, 所有操作都是内存完成, 很快

## 字典的rehash过程

- dict数据结构
  
  - 一个dict持有两个hash表
  
  - 有标明正在hash的索引，若大于等于0则表示正在rehash

- 渐进式hash
  
  - 一次rehash一部分的槽位
  
  - 在每次对dict进行操作时进行
  
  - 在redis的周期函数中执行，每100ms花1ms去随机抽选正在rehash的dict然后进行继续rehash

## 高可用实现

- 主存模式, 故障转移需人工干预

- 哨兵模式, 故障转移由哨兵完成

- 集群模式, 去中心化

## 哨兵模式

#### 基本原理

- 监视主节点状态，当哨兵自身判断主节点down机后，向其他哨兵发起询问，若得到足够多数量的下线判断后，sentinel会将主服务器判断为客观下线，然后进行故障转移

#### 细节

- 最少由3个节点组成

- 使用类似raft的共识算法进行选举

- 哨兵通过订阅master节点的_sentinel_:hello频道来发现其他sentinel, 然后与其他sentinel建立连接以用来完成主观下线和客观下线等功能

#### 故障转移步骤

- 当哨兵发现主节点客观下线后, 开始投票选举进行故障转移的sentinel节点

- 选举步骤
  
  1. 若已经投过票，则2倍的故障转移超时时间内自己不会再成为leader，而是follower
  
  2. 所还未投过票，则转变为candidate
  
  3. 和raft一样，转变为candidate后需要做这几件事
     
     1. 更新故障转移状态为start
     
     2. 当前epoch加1，相当于进入新一轮投票
     
     3. 更新自己的投票超时时间，为当前时间加上1秒内的随机毫秒数
     
     4. 向其他节点发送投票请求
     
     5. 给自己投一票，投票方式为把master结构体里的leader和leader_epoch变为sentinel和它的epoch
  
  4. 其他sentinel收到candidate的投票请求后，如果收到的epoch和当前记录的epoch一样，那么就相当于已经投过票了，就不再给对方投票了，否则投票，投过票的哨兵只能时follower
  
  5. candidate会统计自己的票数，若得票数超过一半并且大于配置文件里的配置数，则自己变为leader开始故障转移
  
  6. 若在选举超时时间内自己的票数没有达到成为leader的要求，那自己的这次选举就失败了
  
  7. 如果在一个epoch内没有candidate成为leader，那就等待2倍故障转移时间后增加epoch继续投票
  
  8. 跟raft不同的是哨兵成为leader后不会通知其他哨兵选举结果，转而是直接进行故障转移，待其他哨兵检测到新的master正常工作后就会去掉客观下线标识，从而不需要进入故障转移流程了

- 故障转移
  
  - 选择新的服务器
  
  - 升级新的服务器
  
  - 若升级超时则重新选择新服务器并升级
  
  - 向从服务器发slaveof命令，让他们同步新的主服务器

## 集群部署

- 基本原理
  
  - 客户端将操作请求发送至服务器节点时, 服务器节点用crc16算法计算key对应的值再取16k的模，根据结果可以得知该key分布在哪个slot中，再通过获取保存在本节点的集群信息获取slot分布的节点，若是本节点则进行操作，否则返回moved给客户端，让客户端重新发送命令到实际上的服务器节点

- 数据分区规则
  
  - 虚拟槽哈希分区(redis使用)
    
    - 共16k个虚拟槽, 使用crc16将数据分散到各个槽位, 然后每个master节点负责部分虚拟槽的读写
  
  - 一致性哈希
    
    - 将存储节点通过hash算法排列在hash环上, 可看作2^32个槽位, 每次数据访问都计算hash, 然后找到顺时针方向最近的节点, 对该节点进行操作
    
    - 增加一个节点时，影响新增节点位置到前一个节点之间分布的数据
    
    - 删除一个节点时，影响删除节点到顺时针方向的下一个节点, 该节点将承载移除节点的所有负载
    
    - 数据倾斜问题
      
      - 节点分布不均就会出现这种问题
      
      - 引入虚拟节点可以解决该问题, 虚拟节点所关联的实际节点将负责该虚拟节点的负载

- slot信息
  
  - 每个节点上都有一个16384个bit位的数组来标识节点上包含的slot信息

- 节点元数据同步
  
  - 基本原理
    
    - 当有节点更新了状态(新节点加入、节点故障、主从角色变化、槽信息变化)时，该节点会随机的向周围几个节点传播消息，收到消息的节点会重复这个过程
  
  - 心跳信息、更新信息包含slot信息
  
  - 使用gossip协议(p2p协议)
  
  - 优点
    
    - 可扩展性、容错、去中心化、最终一致性
  
  - 缺点
    
    - 消息延迟、消息冗余
