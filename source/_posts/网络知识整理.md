---
title: 网络知识整理
date: 2020-03-21 16:46:29
tags:
---

# 网络知识梳理

## TCP和UDP

- tpc面向连接、可靠的流协议。流就是指不间断的数据结构，当应用程序采用tcp发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。tcp为提供可靠性传输，实行“顺序控制”或”重发控制“机制。此外还具备”流控制（流量控制）“、”拥塞控制“、提高网络利用率等众多功能

- udp是不具有可靠性的数据报协议。细微的处理它会交给上层的应用完成。再udp的情况下，虽然数据可以确保发送消息的大小，却不能保证消息一定会到达，因此应用有时会根据自己的需要进行重发处理

- tcp用于在传输层有必要实现可靠传输的情况

- udp主要用于那些对高速传输和实时性要求较高的通信或广播通信

## 端口

- 传输层根据端口号识别本机中正在进行通信的应用程序，并准确地将数据传输

- 不同的传输协议可以使用相同的端口号，但端口资源不同

## TCP/IP四层模型

- 应用层
  
  - 基于TCP：HTTP，SSH，HTTPS
  
  - 基于UDP：DNS，ARP

- 传输层
  
  - 为两台主机上的应用程序提供端到端的通信，与网络层使用的逐跳通讯方式不同，传输层只关心通信的

- 网络层
  
  - 实现数据包的选路和转发

- 数据链路层
  
  - 实现了网卡接口的网络驱动程序，以处理数据在物理媒介上传输

相较于osi七层模型，少了物理层（归到数据链路层），表示层和应用层（被归类到应用层）

## TCP/IP协议

##### 三次握手

- socket编程中，三次握手由客户端执行connect来触发

- 第一次握手：客户端将标志位SYN置为1，随机产生一个序列号seq，并将该数据包发送给服务端，客户端进入SYN_SENT状态

- 第二次握手：服务器收到数据包后由标志位SYN=1知道客户端请求建立连接，服务端将SYN和ACK都置为1，ack=seq+1，然后随机产生一个值seq发送给客户端，服务器进入SYN_RCVD状态

- 第三次握手：客户端收到确认后，检测ack是否为之前发送的序列号加1，ACK是否为1，如果正确则将标志位ACK置为1，ack=服务端给的序号+1，并将该数据包发送给服务端，服务端检查ack是否为自己发送的序号+1，ACK是否为1，如果正确则连接成功建立，客户端和服务端进入ESTABLISHED状态，完成三次握手，随后客户端与服务端之间可以开始传输数据了。

##### 四次挥手

- 断开一个tcp连接时，需要客户端和服务端总共发送4个包以确认连接断开，在socket变成中，这一过程由双方任一方执行close来出发

- 由于TCP连接时全双工的，因此每个方向都必须单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到FIN只是意味着这一方向没有数据流动了，即不会再收到数据了，但是这个tcp连接上仍然能够发送数据，直到这一方向也发送了FIN，首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭

- 步骤：
  
  - 第一次挥手：客户端FIN=M来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态，意思是我客户端已经没有数据要发送给你了，但是如果你服务端还有数据没有发送完，则不必着急关闭连接，可以继续发送数据
  
  - 第二次挥手：服务端收到FIN后，先发送ack=M+1，告诉客户端我收到你的请求了，请你继续等我的消息，这个时候客户端就进入FIN_WAIT_2状态，继续等待服务端的FIN报文
  
  - 第三次挥手：当服务端确认数据已发送完成，则向客户端发送FIN=N报文，告诉客户端我这边数据发完了，准备好关闭连接了，服务端进入LAST_ACK状态
  
  - 第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，爬服务端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果server端没有收到ACK则可以重传，服务端收到ACK后，就知道可以断开连接了，客户端等待2MSL（最大报文段生存时间）后依然没有收到回复，证明服务端已正常关闭，此时客户端也可以关闭连接了
  
  - 双方如果同时发起关闭，则收到对方的关闭请求后就直接从FIN_WAIT_1进入CLOSE_WAIT状态，然后回复ack，各方收到ack后进入TIME_WAIT

通过序列号和确认消息提高可靠性

- 数据包编号后发给另一方，另一方收到后回复下一个期望的数据包编号（编号 + 数据包长度）

超时时间确定

- bsd的unix及windows中，超市都以0.5秒为单位控制，最初超时时间默认值一般为6秒左右

- 数据不会被反复的重发，若达到一定重发次数后，如果仍没有任何确认应答返回，就会判断为网络或端对端主机发生了异常，强制关闭连接，并通知应用通信异常强行终止

- 滑动窗口提升通信性能

为什么要三次握手

- 双方都需要确认自己发送和接收信息的功能正常

- 需要协商双方通信的初始序号，而这一结果双方都得知道才行

- 若改为两次，服务端完成二次握手后则建立连接的话，此时若应答数据没到客户端，服务端以为建立成功，会一直等待数据，但此时客户端可能已经将此连接关闭了，造成服务端资源浪费

- 若是两次挥手，客户端可能第一次发了建立连接的数据包，但一直迟迟无法到达服务端，后续又发了一次，服务端发送建立连接后，数据发送完后释放了连接，但之前客户端发送的建立连接的请求终于到了，此时服务端确认后又建立连接然后发送给客户端确认消息，此时客户端忽略此数据，造成服务端一直等待，浪费资源

为什么要四次挥手

- 为了确保双方都能及时发现对方需要释放连接的请求，比如你要断开连接，但我还有数据要给你发，所以你告诉我一声然后等我数据发完后通知你就可以关闭了，但是后续我发完数据后要是直接发送关闭连接命令，此时若是我这边关闭，那对方要是没收到关闭命令怎么办，他岂不是要等很久，此时我就需要知道他是不是收到了，他收到了就给我回个信然后自己关闭就行，我这等收到他的信息之后再关闭，此时我肯定是知道他会关闭的，然后我自己关闭就好了，但要是没有收到他的回复说明网络可能有问题了，这时候我还是要给他再发一次关闭的命令，再进行重试机制就行了，要是客户端一直没收到关闭命令，那么他恐怕要等待很久才能释放资源了，因为他不知道上游是否还有数据要发，但如果他收到了，只是回复后服务器没收到，那就等最大报文超时时间释放资源就行
